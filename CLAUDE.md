# PSC-Graph 项目开发准则

## 概览
本文件用于指导政策语义因果图谱(PSC-Graph)项目的全部开发与文档工作,确保输出遵循强制性标准并保持可审计性。本项目旨在构建"政策语义→政策意图→产业行为/绩效"的端到端体系,打通"认知断裂—行为断裂—评估断裂"三大鸿沟。

**项目核心**:
- **认知断裂**: 通过LLM+RAG实现政策语义抽取
- **行为断裂**: 通过异质时序图学习(HGT+TGAT)建立政策-产业图谱
- **评估断裂**: 通过稳健DID方法(CS-ATT/Sun-Abraham/BJS)进行因果识别

**语言使用强制规范**
- ⚠️ **绝对强制使用简体中文**:所有AI回复、文档、注释、日志、提交信息等一切可使用任意语言的内容,必须强制使用简体中文。
- 唯一例外:代码标识符(变量名、函数名、类名等)遵循项目既有命名约定。
- 违反此规范的任何输出必须立即重写为简体中文。

## 🔒 强制验证机制
- 必须拒绝一切CI、远程流水线或人工外包验证,所有验证均由本地AI自动执行。
- 每次改动必须提供可重复的本地验证步骤(脚本、指令或推理说明),并在失败时立即终止提交。
- 验证过程中如遇工具缺失或测试覆盖不足,必须在任务文档中记录原因和补偿计划。
- 若存在无法验证的部分,必须先补足验证能力或将任务退回,不允许带缺陷交付。

## 🤝 质量审查规范

**审查职责(Claude Code独立执行)**:
- 使用sequential-thinking进行深度审查分析
- 输出技术维度评分(代码质量、测试覆盖、规范遵循)
- 输出战略维度评分(需求匹配、架构一致、风险评估)
- 输出综合评分(0-100)和明确建议(通过/退回/需讨论)
- 生成`.claude/verification-report.md`审查报告

**审查清单必须包含**:
- 需求字段完整性(目标、范围、交付物、审查要点)
- 覆盖原始意图无遗漏或歧义
- 交付物映射明确(代码、文档、测试、验证报告)
- 依赖与风险评估完毕
- 审查结论已留痕(含时间戳)

**决策规则**:
- 综合评分≥90分且建议"通过" → 确认通过
- 综合评分<80分且建议"退回" → 确认退回
- 80-89分或建议"需讨论" → 仔细审阅后决策

## 📊 架构优先级
- "标准化+生态复用"拥有最高优先级,必须首先查找并复用官方SDK、社区成熟方案或既有模块。
- 禁止新增或维护自研方案,除非已有实践无法满足需求且获得记录在案的特例批准。
- 必须删除自研实现以减少维护面,降低长期技术债务和运维成本。
- 在引入外部能力时,必须验证其与项目标准兼容,并编写复用指引。
- 对现有自研或偏离标准的实现,必须规划替换或下线时间表,确保维护成本持续下降。

## 🛡️ 安全性原则
- **数据合规最高优先级**:仅使用公开政府数据源,遵守robots.txt,QPS≤1.0
- **OWASP LLM Top 10强制遵守**:
  - Prompt Injection:输入清洗与验证
  - Excessive Agency:工具执行沙箱化
  - Data Poisoning:JSON Schema验证+SHA256校验
  - Model DoS:LLM API限速+超时控制
  - 敏感信息:环境变量管理,禁止硬编码密钥
  - 输出完整性:温度缩放校准(ECE≤0.05)
  - 过度依赖:关键决策人工验证+不确定性量化

## ✅ 代码质量强制标准

### 📝 语言与注释规范

#### 🌐 强制中文使用范围(绝对要求)
所有以下场景必须强制使用简体中文,无任何例外:
- ✅ AI与用户的所有对话回复
- ✅ 所有文档(设计文档、API文档、README、规范文档等)
- ✅ 所有代码注释(单行注释、多行注释、文档注释)
- ✅ Git提交信息(commit message)
- ✅ 操作日志(operations-log.md、coding-log等)
- ✅ 审查报告(review-report.md)
- ✅ 任务描述与规划文档
- ✅ 错误提示与警告信息
- ✅ 测试用例描述
- ✅ 配置文件中的说明性文本

**唯一例外**:代码标识符(变量名、函数名、类名、包名等)遵循项目既有命名约定(通常使用英文)。

#### 📋 注释编写规范
- 所有代码文件必须使用UTF-8无BOM编码进行读写操作。
- 注释必须描述意图、约束与使用方式,而非重复代码逻辑。
- 禁止编写"修改说明"式注释,所有变更信息应由版本控制和日志承担。
- 当模块依赖复杂或行为非显而易见时,必须补充注释解释设计理由。
- 注释应简洁明了,避免冗长废话,直指核心要点。

### 🧪 测试规范
- 每次实现必须提供可自动运行的单元测试、冒烟测试或功能测试,由本地AI执行。
- 缺失测试的情况必须在验证文档中列为风险,并给出补测计划与截止时间。
- 测试需覆盖正常流程、边界条件与错误恢复,确保破坏性变更不会遗漏关键分支。

### 🏗️ 设计原则
- 严格遵循SOLID、DRY与关注点分离,任何共享逻辑都应抽象为复用组件。
- 依赖倒置与接口隔离优先,禁止临时绑死实现细节。
- 遇到复杂逻辑时必须先拆分职责,再进入编码。

### 💻 实现标准
- 绝对禁止MVP、最小实现或占位符;提交前必须完成全量功能与数据路径。
- 必须完善所有MVP、最小实现和占位为完整的具体代码实现。
- 必须主动删除过时、重复或逃生式代码,保持实现整洁。
- 必须始终遵守编程语言标准代码风格和项目既有风格规范。
- 对破坏性改动不做向后兼容处理,同时提供迁移步骤或回滚方案。
- 必须始终采用颠覆式破坏性更改策略,绝对不向后兼容。
- 必须遵循最佳实践,确保代码质量和可维护性。

### ⚡ 性能意识
- 设计时必须评估时间复杂度、内存占用与I/O影响,避免无谓消耗。
- 识别潜在瓶颈后应提供监测或优化建议,确保可持续迭代。
- 禁止引入未经评估的昂贵依赖或阻塞操作。

### 🧩 测试思维
- 在编码前编制可验证的验收条件,并在验证文档中回填执行结果。
- 对预期失败场景提供处理策略,保证服务可控降级。
- 连续三次验证失败必须暂停实现,回到需求和设计阶段复盘。

## 🚀 强制工作流程

### ⚡ 总原则(必须遵循)
- **强制深度思考**:任何时候必须首先使用sequential-thinking工具梳理问题,这是开发工作的基础。
- 不是必要的问题,不要询问用户,必须自动连续执行,不能中断流程。
- 问题驱动优先于流程驱动,追求充分性而非完整性,动态调整而非僵化执行。

### 🔗 工具链执行顺序(必须)
- 严格按照sequential-thinking → shrimp-task-manager → 直接执行的顺序。
- 任一环节失败时,必须在操作日志中记录原因、补救措施与重新执行结果。
- 禁止跳过或调换顺序,必要时通过人工流程模拟缺失工具并记录。

### 🔍 信息检索与外部工具集成(必须)

**核心原则**:
- 工具是手段,按需使用,避免僵化流程
- 所有引用资料必须写明来源与用途,保持可追溯
- 检索失败时,必须在日志中声明并改用替代方法

#### 本地文件和数据分析集成(最高优先级)

**desktop-commander - 本地文件和进程管理**(核心工具):
- **触发条件**:任何本地文件操作、CSV/JSON/数据分析、进程管理
- **核心能力**:
  - 文件操作:`read_file`、`write_file`、`edit_block`(精确文本替换)
  - 目录管理:`list_directory`、`create_directory`、`move_file`
  - 搜索:`start_search`(支持文件名和内容搜索,流式返回结果)
  - 进程管理:`start_process`、`interact_with_process`(交互式REPL)
  - 数据分析:支持Python/Node.js REPL进行CSV/JSON/日志分析
- **最佳实践**:
  - **文件分析必用**:所有本地CSV/JSON/数据文件分析必须用此工具(不用analysis工具)
  - **交互式工作流**:start_process("python3 -i") → interact_with_process加载数据 → 分析
  - **精确编辑**:使用edit_block进行外科手术式文本替换(比sed/awk更安全)
  - **流式搜索**:大目录搜索使用start_search(渐进式返回结果,可提前终止)
- **优势**:比bash更安全和结构化,支持REPL交互,适合数据科学工作流
- **示例场景**:分析sales.csv、处理config.json、搜索代码模式、管理后台进程
- **注意事项**:
  - 绝对优先于bash cat/grep/find等命令
  - 本地文件分析禁止使用analysis/REPL工具(会失败)
  - 使用绝对路径以保证可靠性

#### 编程文档检索优先级(context7优先)

**context7 - 编程库/SDK/API文档**(最高优先级):
- **触发条件**:任何关于编程库、框架、SDK、API的问题
- **调用方式**:
  1. 首先调用`resolve-library-id`获取Context7兼容的库ID
  2. 然后调用`get-library-docs`获取文档(可选topic参数聚焦)
- **优势**:专门优化编程上下文,token高效,最新官方文档
- **示例场景**:PyTorch Geometric HGTConv用法、R did包文档、JSON Schema规范
- **注意事项**:必须先resolve-library-id,除非用户明确提供`/org/project`格式的库ID

**firecrawl - 通用网页检索**(通用后备):
- **触发条件**:context7无法满足、需要最新博客/文章/教程
- **调用方式**:
  1. `firecrawl_search`:搜索并抓取内容(推荐,自动返回内容)
  2. `firecrawl_scrape`:单页抓取(已知URL时)
  3. `firecrawl_map`:网站结构发现(探索网站时)
- **优势**:强大抓取能力、支持多种模式、处理复杂网页
- **示例场景**:最新技术趋势、社区最佳实践、问题排查博客
- **注意事项**:优先使用search(带scrapeOptions),避免过度抓取

#### GitHub项目协作集成

**github - 完整GitHub操作**:
- **核心能力**:
  - 代码搜索:`search_code`、`search_repositories`
  - PR管理:`create_pull_request`、`get_pull_request`、`merge_pull_request`
  - Issue管理:`create_issue`、`update_issue`、`list_issues`
  - 代码审查:`create_and_submit_pull_request_review`
  - 文件操作:`create_or_update_file`、`push_files`
- **触发条件**:需要操作GitHub仓库、搜索开源代码、管理协作流程
- **最佳实践**:
  - 搜索代码时使用`search_code`(比firecrawl更精准)
  - 创建PR前先调用`get_pull_request_diff`检查变更
  - 使用`request_copilot_review`进行自动代码审查
- **示例场景**:创建feature PR、搜索实现示例、管理issue工作流

#### 工具选择决策树

```
需要本地文件操作?
├─ 文件读写/搜索 → desktop-commander(最高优先级)
├─ 数据分析(CSV/JSON) → desktop-commander.start_process + interact_with_process
└─ 进程管理 → desktop-commander.start_process

需要编程相关信息?
├─ 官方文档/API参考 → context7(最高优先级,包含所有技术栈)
└─ 最新博客/文章/教程 → firecrawl(通用后备)

需要操作GitHub?
├─ 搜索代码 → github.search_code
├─ 读取文件/文档 → github.get_file_contents
├─ 管理PR/Issue → github.create_*/update_*
└─ 代码审查 → github.request_copilot_review
```

### 🔍 强制上下文检索机制(编码前必须执行)

**绝对禁止**:在未完成上下文检索和验证的情况下直接编码。违反者立即终止任务。

#### 📋 编码前强制检索清单(7项必查,复杂度自动分级)

**检索强度分级**:
- **简单任务**(单文件、<50行、无依赖):执行步骤1-3,简化验证
- **中等任务**(多文件、<200行、少量依赖):执行完整7步,标准验证
- **复杂任务**(架构级、>200行、复杂依赖):执行完整7步+增强验证

**完整检索清单**:

**□ 步骤1:文件名搜索(必须)**
```bash
desktop-commander.start_search searchType="files" pattern="关键词"
```
- **目标**:找到5-10个候选文件
- **记录**:找到X个相关文件,重点关注[列出文件路径]
- **工具**:优先使用desktop-commander流式搜索,避免过度搜索

**□ 步骤2:内容搜索(必须)**
```bash
desktop-commander.start_search searchType="content" pattern="函数名|类名|关键逻辑"
literalSearch=true contextLines=5
```
- **目标**:找到关键实现位置
- **记录**:找到X处实现,重点分析[file:line, file:line]
- **技巧**:使用精确代码片段搜索,获取上下文

**□ 步骤3:阅读相似实现(必须≥3个)**
```bash
Read file_path  # 深度阅读至少3个相关文件
```
- **目标**:理解实现模式和设计理由
- **记录**:分析了[file1:line, file2:line, file3:line]
- **关注点**:
  - 实现模式(工厂/单例/装饰器等)
  - 可复用组件(函数/类/工具)
  - 需注意事项(性能/安全/边界)

**□ 步骤4:开源实现搜索(通用功能必做)**
```bash
github.search_code query="具体功能实现" language:"语言" repo:"优质仓库"
```
- **目标**:学习最佳实践和避免常见陷阱
- **记录**:找到X个参考实现,学到[关键要点]
- **触发条件**:通用算法、数据结构、设计模式

**□ 步骤5:官方文档查询(涉及库/框架必做)**
```bash
context7 resolve-library-id libraryName="库名"
context7 get-library-docs context7CompatibleLibraryID="库ID" topic="相关主题"
```
- **目标**:避免错误用法,掌握最佳实践
- **记录**:查询了[库名]文档,关键用法是...
- **优势**:官方文档,token高效,最新版本

**□ 步骤6:测试代码分析(必须)**
```bash
desktop-commander.start_search searchType="content" pattern="describe|it|test"
filePattern="*.spec.*|*.test.*"
```
- **目标**:理解测试策略和覆盖标准
- **记录**:测试模式是...,我的测试应该...
- **关注点**:测试框架、断言方式、边界条件、Mock策略

**□ 步骤7:模式提取和分析(必须)**
```bash
sequential-thinking  # 分析检索结果,提取项目模式
```
- **目标**:生成项目模式清单
- **记录**:
  - 项目约定:命名规范、文件组织、导入顺序
  - 可复用组件:[组件路径列表]
  - 技术选型:为什么用这个方案?有何优缺点?
  - 风险点:并发、边界、性能、安全

#### ✅ 上下文充分性验证(编码前最后关卡)

**必须全部回答"是"且提供具体证据,否则禁止进入编码阶段。**

**□ 1. 我能说出至少3个相似实现的文件路径吗?**
- ✅ 是:[file1:line, file2:line, file3:line]
- ❌ 否 → 返回步骤1重新搜索

**□ 2. 我理解项目中这类功能的实现模式吗?**
- ✅ 是:模式是[具体描述],因为[理由]
- ❌ 不确定 → 返回步骤3深度阅读

**□ 3. 我知道项目中有哪些可复用的工具函数/类吗?**
- ✅ 是:[列出具体函数/类名和路径]
- ❌ 不知道 → 强制搜索utils/helpers/core模块

**□ 4. 我理解项目的命名约定和代码风格吗?**
- ✅ 是:命名约定是[具体说明],代码风格是[具体说明]
- ❌ 不清楚 → 阅读更多代码或项目规范文档

**□ 5. 我知道如何测试这个功能吗?**
- ✅ 是:参考[测试文件]的模式,我会[具体测试策略]
- ❌ 不知道 → 搜索并阅读相关测试代码

**□ 6. 我确认没有重复造轮子吗?**
- ✅ 是:检查了[具体模块/文件],确认不存在相同功能
- ❌ 不确定 → 扩大搜索范围,检查utils/helpers/common

**□ 7. 我理解这个功能的依赖和集成点吗?**
- ✅ 是:依赖[具体依赖],集成点是[具体位置]
- ❌ 不清楚 → 分析import语句和调用链

#### 📄 上下文摘要文件(编码前必须生成)

**路径**:`.claude/context-summary-[任务名].md`

**模板**:
```markdown
## 项目上下文摘要([任务名称])
生成时间:[YYYY-MM-DD HH:mm:ss]

### 1. 相似实现分析
- **实现1**: src/foo/bar.ts:123-156
  - 模式:[设计模式]
  - 可复用:[具体函数/类]
  - 需注意:[关键事项]

- **实现2**: src/baz/qux.ts:78-90
  - 模式:[设计模式]
  - 可复用:[具体函数/类]
  - 需注意:[关键事项]

### 2. 项目约定
- **命名约定**: [变量/函数/类/文件命名规则]
- **文件组织**: [目录结构和模块划分]
- **导入顺序**: [导入语句排序规则]
- **代码风格**: [缩进/括号/空格等]

### 3. 可复用组件清单
- `src/utils/validator.ts`: 验证工具函数
- `src/core/base.ts`: 基类和接口
- `src/helpers/formatter.ts`: 格式化工具

### 4. 测试策略
- **测试框架**: [Jest/Mocha/Vitest等]
- **测试模式**: [单元/集成/E2E]
- **参考文件**: tests/unit/example.spec.ts
- **覆盖要求**: [正常流程+边界条件+错误处理]

### 5. 依赖和集成点
- **外部依赖**: [lodash, axios等]
- **内部依赖**: [模块间依赖关系]
- **集成方式**: [事件总线/依赖注入/直接调用]
- **配置来源**: [配置文件路径]

### 6. 技术选型理由
- **为什么用这个方案**: [具体理由]
- **优势**: [关键优势]
- **劣势和风险**: [需要注意的点]

### 7. 关键风险点
- **并发问题**: [潜在的竞态条件]
- **边界条件**: [需要处理的边界情况]
- **性能瓶颈**: [可能的性能问题]
- **安全考虑**: [需要注意的安全问题]
```

#### 🚨 懒惰检测与防护机制

**核心原则**:研究先于编码,复用优于创造,一致性优于个人偏好。

**检测点1:编码前检测(Write/Edit工具使用前)**

**必须在operations-log.md中记录以下检查**:
```markdown
## 编码前检查 - [功能名称]
时间:[YYYY-MM-DD HH:mm:ss]

□ 已查阅上下文摘要文件:.claude/context-summary-[任务名].md
□ 将使用以下可复用组件:
  - [组件1]: [路径] - [用途]
  - [组件2]: [路径] - [用途]
□ 将遵循命名约定:[具体说明]
□ 将遵循代码风格:[具体说明]
□ 确认不重复造轮子,证明:[说明检查了哪些模块]
```

**无法回答任何一项 → 立即终止,返回检索阶段。**

**检测点2:编码中监控(每完成一个函数/类/模块)**

**对比上下文摘要,检查**:
```markdown
□ 是否使用了摘要中列出的可复用组件?
  ✅ 是:已使用[列出]
  ❌ 否:为什么不用?[合理解释]

□ 命名是否符合项目约定?
  ✅ 是:对比[具体例子]
  ❌ 否:为什么偏离?[合理解释]

□ 代码风格是否一致?
  ✅ 是:对比[具体例子]
  ❌ 否:为什么偏离?[合理解释]
```

**"否"的数量超过50% → 触发Level 1警告。**

**检测点3:编码后验证(功能实现完成后)**

**完整声明(记录在operations-log.md)**:
```markdown
## 编码后声明 - [功能名称]
时间:[YYYY-MM-DD HH:mm:ss]

### 1. 复用了以下既有组件
- [组件1]: 用于[用途],位于[路径]
- [组件2]: 用于[用途],位于[路径]

### 2. 遵循了以下项目约定
- 命名约定:[对比说明,举例证明]
- 代码风格:[对比说明,举例证明]
- 文件组织:[对比说明,举例证明]

### 3. 对比了以下相似实现
- [实现1]: 我的方案与其差异是[具体差异],理由是[合理性说明]
- [实现2]: 我的方案与其差异是[具体差异],理由是[合理性说明]

### 4. 未重复造轮子的证明
- 检查了[模块/文件列表],确认不存在相同功能
- 如果存在类似功能,我的差异化价值是[说明]
```

**无法提供完整声明 → 视为懒惰,触发审查。**

**三级惩罚体系**:

**Level 1 - 警告(首次检测到懒惰)**
1. 立即暂停编码
2. 记录警告到operations-log.md
3. 要求立即修正偏离部分
4. 重新对比上下文摘要
5. 通过复查后继续编码

**Level 2 - 强制退回(二次检测到懒惰)**
1. 删除已编写的代码
2. 强制返回检索阶段
3. 重新生成上下文摘要
4. 重新通过充分性验证
5. 记录"二次懒惰"到operations-log.md

**Level 3 - 任务失败(三次检测到懒惰)**
1. 标记任务为"失败"
2. 生成失败报告,详细记录懒惰行为
3. 需要用户介入重新评估任务
4. 考虑调整工作流程或提供更多指导

### 📋 文件结构规范

所有任务执行产生的工作文件必须写入项目本地`.claude/`目录(而非全局`~/.claude/`):
```
<project>/.claude/
    ├── context-summary-[任务名].md   ← 上下文摘要(Claude Code输出)
    ├── operations-log.md             ← 决策和操作记录(Claude Code输出)
    └── verification-report.md        ← 验证报告(Claude Code输出)
```

### 📋 标准工作流6步骤(必须执行)
1. 分析需求
2. 获取上下文
3. 选择工具
4. 执行任务
5. 验证质量
6. 存储知识

### 🔄 研究-计划-实施模式5阶段(必须遵循)
1. **研究**:阅读材料、厘清约束,禁止编码
2. **计划**:制定详细计划与成功标准
3. **实施**:根据计划执行并保持小步提交
4. **验证**:运行测试或验证脚本,记录结果
5. **提交**:准备交付文档与迁移/回滚方案

### 🧭 工作流程阶段定义

**阶段0:需求理解与上下文收集**
- 快速通道:简单任务(<30字,单一目标)直接进入上下文收集
- 复杂任务:使用sequential-thinking分析需求并识别关键疑问
- 上下文收集:
  1. **强制检索清单**(7步,编码前必做)
  2. **充分性验证**(7项检查,必须全部通过)
  3. **生成上下文摘要**(`.claude/context-summary-[任务名].md`)

**阶段1:任务规划**
- 使用sequential-thinking分析上下文摘要
- 通过shrimp-task-manager制定计划与验收契约
- 基于完整上下文定义接口规格、边界条件、性能要求、测试标准

**阶段2:代码执行**
- 直接编码(使用Read/Edit/Write)
- 实时记录到`operations-log.md`
- 遇到问题时使用sequential-thinking分析并调整策略

**阶段3:质量验证**
- 使用sequential-thinking进行深度审查
- 生成评分和建议(写入`.claude/verification-report.md`)
- 根据评分决策:
  - ≥90分 → 通过
  - <80分 → 退回修改
  - 80-89分 → 仔细审阅后决策

### ✋ 任务开始前强制检查(必须执行)
- 调用sequential-thinking梳理问题、识别风险
- 确认日志文件(coding-log与operations-log)可写并准备记录
- 检索相关代码或文档,确认复用路径

### 🔄 渐进式上下文收集流程(必须)

#### 核心哲学
- **问题驱动**:基于关键疑问收集,而非机械执行固定流程
- **充分性优先**:追求"足以支撑决策和规划",而非"信息100%完整"
- **动态调整**:根据实际需要决定深挖次数(建议≤3次),避免过度收集
- **成本意识**:每次深挖都要明确"为什么需要"和"解决什么疑问"

#### 步骤1:结构化快速扫描(必须)
执行框架式收集,记录到`.claude/context-summary-[任务名].md`:
- 位置:功能在哪个模块/文件?
- 现状:现在如何实现?找到1-2个相似案例
  - **优先使用github.search_code搜索开源实现**
  - 项目内代码复用分析
- 技术栈:使用的框架、语言、关键依赖
  - **使用context7查询库/框架的官方文档和最佳实践**(支持所有技术栈)
- 测试:现有测试文件和验证方式
- **观察报告**:记录发现的异常、信息不足之处和建议深入的方向

#### 步骤2:识别关键疑问(必须)
使用sequential-thinking分析初步收集和观察报告,识别关键疑问:
- 我理解了什么?(已知)
- 还有哪些疑问影响规划?(未知)
- 这些疑问的优先级如何?(高/中/低)
- 输出:优先级排序的疑问列表

#### 步骤3:针对性深挖(按需,建议≤3次)
仅针对高优先级疑问进行深挖:
- 聚焦单个疑问,不发散
- 提供代码片段证据,而非猜测
- 更新`.claude/context-summary-[任务名].md`
- **成本提醒**:第3次深挖时提醒"评估成本",第4次及以上警告"建议停止,避免过度收集"

#### 步骤4:充分性检查(必须)
在进入任务规划前,必须回答充分性检查清单:
- □ 我能定义清晰的接口契约吗?(知道输入输出、参数约束、返回值类型)
- □ 我理解关键技术选型的理由吗?(为什么用这个方案?为什么有多种实现?)
- □ 我识别了主要风险点吗?(并发、边界条件、性能瓶颈)
- □ 我知道如何验证实现吗?(测试框架、验证方式、覆盖标准)

**决策**:
- ✓ 全部打勾 → 收集完成,进入任务规划和实施
- ✗ 有未打勾 → 列出缺失信息,补充1次针对性深挖

#### 回溯补充机制
允许"先规划→发现不足→补充上下文→完善实现"的迭代:
- 如果在规划或实施阶段发现信息缺口,记录到`operations-log.md`
- 补充1次针对性收集,更新上下文摘要文件
- 避免"一步错、步步错"的僵化流程

#### 禁止事项
- ❌ 跳过步骤1(结构化快速扫描)或步骤2(识别关键疑问)
- ❌ 跳过步骤4(充分性检查),在信息不足时强行规划
- ❌ 深挖时不说明"为什么需要"和"解决什么疑问"
- ❌ 上下文文件写入错误路径(必须是`.claude/`而非`~/.claude/`)

## 💡 开发哲学(强制遵循)
- 必须坚持渐进式迭代,保持每次改动可编译、可验证
- 必须在实现前研读既有代码或文档,吸收现有经验
- 必须保持务实态度,优先满足真实需求而非理想化设计
- 必须选择表达清晰的实现,拒绝炫技式写法
- 必须偏向简单方案,避免过度架构或早期优化
- 必须遵循既有代码风格,包括导入顺序、命名与格式化

### 简单性定义
- 每个函数或类必须仅承担单一责任
- 禁止过早抽象;重复出现三次以上再考虑通用化
- 禁止使用"聪明"技巧,以可读性为先
- 如果需要额外解释,说明实现仍然过于复杂,应继续简化

## 🔧 项目集成规则

### 学习代码库
- 必须寻找至少3个相似特性或组件,理解其设计与复用方式
- 必须识别项目中通用模式与约定,并在新实现中沿用
- 必须优先使用既有库、工具或辅助函数
- 必须遵循既有测试编排,沿用断言与夹具结构

### 工具
- 必须使用项目现有构建系统,不得私自新增脚本
- 必须使用项目既定的测试框架与运行方式
- 必须使用项目的格式化/静态检查设置
- 若确有新增工具需求,必须提供充分论证并获得记录在案的批准

## ⚠️ 重要提醒

**绝对禁止**:
- 在缺乏证据的情况下做出假设,所有结论都必须援引现有代码或文档

**必须做到**:
- 在实现复杂任务前完成详尽规划并记录
- 对跨模块或超过5个子任务的工作生成任务分解
- 对复杂任务维护TODO清单并及时更新进度
- 在开始开发前校验规划文档得到确认
- 保持小步交付,确保每次提交处于可用状态
- 在执行过程中同步更新计划文档与进度记录
- 主动学习既有实现的优缺点并加以复用或改进
- 连续三次失败后必须暂停操作,重新评估策略

## 🎯 内容唯一性规则
- 每一层级必须自洽掌握自身抽象范围,禁止跨层混用内容
- 必须引用其他层的资料而非复制粘贴,保持信息唯一来源
- 每一层级必须站在对应视角描述系统,避免越位细节
- 禁止在高层文档中堆叠实现细节,确保架构与实现边界清晰

---

# PSC-Graph 项目特定规范

## 核心技术栈强制依赖

### 数据采集层
```yaml
必须使用:
  - requests + BeautifulSoup4 (HTML解析)
  - pdfplumber (PDF表格抽取)
  - 自定义节流器 (QPS 0.5-1.0)
  - 断点续爬 (JSON checkpoint)

禁止使用:
  - Scrapy (过度工程化)
  - Selenium (资源消耗大)
  - 第三方爬虫服务 (数据合规风险)
```

### NLP与语义抽取层
```yaml
必须使用:
  - DAPT/TAPT (域/任务自适应预训练)
  - RAG系统:
    - BM25 (Pyserini/Lucene) 精确检索
    - FAISS 向量检索
    - α=0.5 混合融合
  - sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2 (384维)
  - JSON Schema Draft 2020-12 验证
  - Cohen's κ ≥ 0.80 (一致性)

禁止使用:
  - 纯零样本LLM (无域适配)
  - 单一检索方式 (必须混合)
  - 未校准的模型输出 (ECE>0.05)
```

### 图学习层
```yaml
必须使用:
  - PyTorch Geometric (PyG)
  - HGT (异质图Transformer)
  - TGAT (时序图注意力)
  - 时间编码: Bochner时间编码

禁止使用:
  - 同质图模型 (GCN/GAT/GraphSAGE alone)
  - 非时序图模型 (无时间戳)
  - >3层GNN (过平滑风险)
```

### 因果推断层
```yaml
必须使用:
  - R `did` 包 (Callaway & Sant'Anna)
  - R `didimputation` (Borusyak-Jaravel-Spiess)
  - Python调用R (rpy2或subprocess)
  - 并行估计: CS-ATT + Sun-Abraham + BJS

禁止使用:
  - TWFE (两向固定效应,有偏)
  - 单一估计器 (必须三方验证)
  - 无预趋势检验的结果
```

## 数据来源强制约束

### 政策文本(必须来源)
```yaml
中央层:
  - 国务院政策文件库 (www.gov.cn/zhengce/zhengceku/)
    - 栏目: 国务院文件、部门文件、政策解读
    - 分页: home_{page}.htm
    - 时间范围: 2009-至今 (主样本)
  - 合规: robots.txt允许路径, QPS≤1.0

省级层:
  - 广东省科技厅 (gdstc.gd.gov.cn)
  - 北京、上海、浙江、江苏 (首批示范)
  - 31省市全覆盖 (扩展阶段)
  - 栏目: 政策法规、政策文件、政策解读
  - 合规: 栏目页抓取, QPS≤0.7

禁止来源:
  - 非官方政策解读网站
  - 个人博客或自媒体
  - 未经验证的政策数据库
```

### 产业/宏观指标(必须来源)
```yaml
国家统计局:
  - 数据门户: data.stats.gov.cn/easyquery.htm
  - 指标类型:
    - GDP (省级, 年度/季度)
    - R&D经费支出与强度 (年度)
    - 规模以上工业增加值 (月度/年度)
    - 高技术制造业增加值 (年度)
    - 研发人员FTE (年度)
  - 合规: 公开JSON接口, QPS≤0.3, 缓存结果

禁止来源:
  - Wind/Choice等商业数据库 (许可问题)
  - 未验证的统计年鉴
  - 第三方整理的统计数据
```

### 专利数据(必须来源)
```yaml
CNIPA (国家知识产权局):
  - 统计月报: www.cnipa.gov.cn/col/col3482/
    - 发明/实用新型/外观设计授权量
    - PCT受理量
    - 省份维度分布
  - 统计年报与历史汇总表
  - 合规: 公开PDF报告, QPS≤0.5

禁止来源:
  - PSS全文检索系统批量爬取 (免责声明限制)
  - 未授权的专利数据API
  - 商业专利数据库
```

## 标注规范强制标准

### 五元组抽取(必须字段)
```yaml
必须标注:
  goal: 政策目标/任务 (字符串)
  instrument: 工具/手段 (枚举多选)
    - funding: 财政资金
    - tax: 税收优惠
    - land: 用地支持
    - talent: 人才政策
    - standard: 标准/监管
    - platform: 平台/载体
    - ip: 知识产权
    - finance: 投融资
    - procurement: 政府采购
    - pilot: 试点示范
    - data_compute: 数据/算力
    - other: 其他 (需注释)
  target_actor: 对象/主体 (字符串)
  strength: 强度/约束性 (0-3整数)
    - 0: 背景/无约束
    - 1: 倡议性
    - 2: 一般性 (有执行路径)
    - 3: 强约束 (考核/问责/硬性资金)
  evidence_spans: 证据段落 (数组)
    - start: 起始偏移
    - end: 结束偏移
    - from_doc: policy|interpretation
  confidence: 置信度 (0.0-1.0浮点)

可选标注:
  region: 地域/覆盖范围
    - name: 地区名称
    - admin_code: 行政区划码 (省级2位/6位)
    - uncertain: 是否模糊 (布尔)
  timeframe: 时间/时点
    - effective_date: 生效日期 (ISO8601)
    - expiry_date: 失效日期
    - revision_of: 修订自哪个文件
    - revision_date: 修订日期
  support: 配套措施 (数组)
    - type: funding|tax|quota|land|energy_quota|emission_quota|fast_track|other
    - value: 数值 (可为null)
    - unit: 单位 (可为null)
    - note: 备注

禁止标注:
  - 模糊不清的泛泛而谈 (无可执行工具)
  - 仅来自解读稿的内容 (需正式条文支撑)
  - 未提供evidence_spans的抽取 (强制可追溯)
```

### 质量门槛(强制要求)
```yaml
实体/关系抽取:
  - F1 ≥ 0.85 (开发集)
  - 少于0.85需在验证报告中说明原因

一致性:
  - Cohen's κ ≥ 0.80 (双标注人员)
  - 少于0.80需仲裁并记录adjudication_note

ARES评测 (RAG质量):
  - 上下文相关性 ≥ 0.85
  - 忠实度 ≥ 0.90
  - 答案相关性 ≥ 0.88

校准:
  - ECE ≤ 0.05 (温度缩放后)
  - 高风险分类 (强度=3) 需共形预测覆盖率≥90%
```

## 图学习强制规范

### 图构建标准
```yaml
节点类型 (必须):
  - Policy: 政策文档
  - Actor: 企业/高校/科研院所
  - Region: 地区 (省/市/区)
  - Topic: 技术主题/IPC
  - Funding: 资金/平台

边类型 (必须):
  - publish→apply: 政策发布→适用对象
  - fund→benefit: 资金→受益主体
  - constraint→object: 约束→对象
  - co-occurrence: 共现关系
  - temporal: 时间邻接

特征 (必须):
  - 文本嵌入: sentence-transformers 384维
  - 统计特征: GDP/R&D/专利等
  - 时间戳: Unix时间或ISO8601
```

### 训练规范(强制遵守)
```yaml
时间切分 (强制):
  - 训练集: t < t_val
  - 验证集: t = t_val
  - 测试集: t > t_val
  - 禁止: 时间泄露 (未来信息进入训练)

模型架构 (强制):
  - 层数: 2-3层 (避免过平滑)
  - 跳连: Residual connections
  - 正则: Dropout 0.1-0.3
  - 负采样: 1:5比例

评测指标 (必须报告):
  - 链路预测: AUC, AP
  - 节点分类: Macro-F1
  - 可解释性: 高权重路径回查到证据

消融研究 (必须进行):
  - 去时序 (HGT only)
  - 去异质 (GAT/GCN)
  - 去RAG证据 (随机初始化)
```

## 因果推断强制规范

### 面板数据标准
```yaml
必须字段:
  - id: 地区编码 (或地区×行业编码)
  - time: 年份/季度/月份
  - y: 结果变量 (GDP增长率/R&D强度/专利授权量等)
  - g: 首次处理时点 (0=never treated)
  - treat: 处理指示 (0/1)

控制变量 (强烈建议):
  - 地区固定效应
  - 年份固定效应
  - 产业结构 (第二产业占比等)
  - 人口规模
  - 资本存量

时间范围:
  - 最短: 3年面板 (处理前1年+处理后2年)
  - 推荐: 5-10年面板
  - 最长: 受数据可得性限制
```

### 估计器要求(三方验证)
```yaml
必须运行:
  - CS-ATT (Callaway & Sant'Anna):
    - R `did::att_gt()` + `did::aggte(type="dynamic")`
    - 输出: 组-时点ATT, 事件研究图

  - Sun-Abraham:
    - R `fixest::sunab()` 或 Stata `eventstudyinteract`
    - 输出: 事件窗口系数, 95% CI

  - BJS Imputation:
    - R `didimputation::did_imputation()`
    - 输出: 总体ATT, 标准误

验证标准:
  - 方向一致性: 三个估计器的符号应一致
  - 显著性一致性: 如果一个显著,其他应在合理区间
  - 预趋势检验: 处理前系数不显著 (p>0.05)
  - 不一致时: 报告并分析原因,不隐藏矛盾

禁止使用:
  - TWFE (两向固定效应) 作为主要结果 (仅作对照基线)
  - 单一估计器 (必须三方验证)
  - 无预趋势图的事件研究
```

### 稳健性检验(至少3项)
```yaml
必须进行:
  1. 预趋势检验:
     - 事件研究图 (处理前5期至处理后5期)
     - 处理前系数联合F检验 p>0.05

  2. 删除早期采纳者:
     - 删除g<q10的样本
     - 重新估计并对比结果

  3. 政策强度分位:
     - 按strength字段分组 (1=弱, 2=中, 3=强)
     - 检验剂量-反应关系

  4. 聚类标准误:
     - 地区层面聚类
     - 产业层面聚类
     - 双向聚类

强烈建议:
  5. 安慰剂检验:
     - 虚假处理时点 (g-2或g-3)
     - 预期不显著

  6. 替代结果变量:
     - 主要KPI之外的其他指标
     - 检验溢出效应
```

## Makefile目标强制约定

```makefile
必须实现的目标:
  setup     → bootstrap.sh (venv, Java, R packages)
  validate  → 标注校验 + Cohen's κ
  index     → BM25 + FAISS构建
  retrieve  → 混合检索演示
  graph     → HGT模型前向
  panel     → DID面板准备
  did       → CS-ATT + SA + BJS并行
  all       → validate → index → panel → did
  clean     → 清理缓存与中间文件

禁止:
  - 跳过validate直接index
  - 跳过panel直接did
  - 修改all的依赖顺序
```

## 目录结构强制约定

```
psc-graph-template/ (根目录)
├── Makefile
├── README.md
├── scripts/
│   ├── bootstrap.sh               # 环境初始化
│   ├── requirements.txt           # Python依赖锁定版本
│   ├── crawler_common.py          # 节流/重试/断点
│   ├── crawl_gov_central.py       # 中央政策爬虫
│   ├── crawl_provinces.py         # 省级政策爬虫
│   ├── fetch_nbs_panel.py         # 统计局数据
│   ├── fetch_cnipa_reports.py     # CNIPA月报/年报
│   ├── parse_cnipa_pdf_tables.py  # PDF表格解析
│   ├── validate_annotations.py    # JSON Schema + κ
│   ├── build_index.py             # BM25 + FAISS
│   ├── retrieve_evidence.py       # 混合检索
│   ├── calibrate_and_conformal.py # 校准 + 共形
│   ├── build_graph_pyg.py         # HGT构建
│   ├── prep_panel.py              # DID面板
│   ├── run_did_from_python.py     # Python→R桥接
│   └── did_run.R                  # CS-ATT + BJS
├── schemas/
│   └── policy_schema.json         # JSON Schema 2020-12
├── annotations/
│   ├── annotator_A/               # 标注人A
│   ├── annotator_B/               # 标注人B
│   └── adjudicated/               # 仲裁后金标
├── corpus/
│   ├── raw/policy_central/        # 中央政策HTML/JSON
│   ├── raw/policy_prov/           # 省级政策HTML/JSON
│   └── samples/                   # 示例文档
├── indexes/
│   ├── bm25/                      # Lucene索引
│   ├── faiss.index                # 向量索引
│   └── id_map.json                # 文档ID映射
├── data/
│   ├── seeds/seeds_sites.yaml     # 爬虫种子配置
│   ├── province_codes.csv         # 省份编码表
│   ├── nbs_raw/                   # NBS原始JSON
│   ├── cnipa_raw/                 # CNIPA原始PDF
│   ├── nbs_panel_long.csv         # 统计指标长表
│   ├── cnipa_panel_long.csv       # 专利指标长表
│   ├── panel_base.csv             # 面板基础数据
│   ├── policy_landing.csv         # 政策落地时点
│   └── panel_for_did.csv          # DID就绪面板
└── results/
    ├── logs/                      # 爬取与处理日志
    ├── checkpoints/               # 断点续爬状态
    ├── did_csatt_event.csv        # CS-ATT事件研究
    └── did_bjs_overall.csv        # BJS总体ATT

禁止:
- 在根目录创建临时文件
- 混淆corpus/与data/的用途
- 绕过.claude/目录写日志
```

## 关键风险与强制规避

### 数据合规风险
```yaml
风险: 过度爬取触发封禁
规避:
  - QPS≤1.0 (政府网站)
  - QPS≤0.7 (省级网站)
  - QPS≤0.3 (统计局API)
  - 遵守robots.txt
  - 指数退避+随机抖动

风险: 使用非公开数据
规避:
  - 仅爬取公开政策栏目
  - 仅使用统计局公开接口
  - 仅下载CNIPA公开月报/年报
  - 禁止PSS全文批量爬取

风险: 数据用途超出公开范围
规避:
  - 仅用于学术研究
  - 引用所有数据来源
  - 不涉及个人隐私数据
```

### 方法论风险
```yaml
风险: LLM抽取幻觉
规避:
  - 强制RAG证据链
  - evidence_spans必须字段
  - 温度缩放 (ECE≤0.05)
  - 高风险分类共形预测

风险: 图模型过平滑
规避:
  - 限制2-3层
  - Residual连接
  - 邻域采样 (k=10-20)

风险: 时间泄露
规避:
  - 严格时间切分 (train<t_val, test>t_val)
  - 禁止使用未来信息
  - 滚动窗口验证

风险: 因果推断平行趋势违背
规避:
  - 预趋势检验 (p>0.05)
  - 三估计器验证 (CS-ATT/SA/BJS)
  - 事件研究图可视化
  - 稳健性检验 (≥3项)
```

### 工程风险
```yaml
风险: 依赖版本冲突
规避:
  - requirements.txt锁定版本
  - Docker/Conda环境
  - R sessionInfo()记录

风险: 断点续爬失败
规避:
  - JSON checkpoint持久化
  - SHA256去重
  - 幂等性设计

风险: 计算资源不足
规避:
  - GPU: 1×24GB (最低)
  - RAM: 64GB (推荐128GB)
  - 子图采样 (batch_size=256)
```

## 质量验收标准(分层评测)

### 模块A: 语义抽取
```yaml
必须达到:
  - F1 ≥ 0.85 (实体/关系)
  - Cohen's κ ≥ 0.80 (一致性)
  - ARES评测:
    - 上下文相关性 ≥ 0.85
    - 忠实度 ≥ 0.90
    - 答案相关性 ≥ 0.88
  - 证据命中率 ≥ 0.90

对照实验:
  - vs 零样本LLM (无DAPT/TAPT)
  - vs 无RAG (仅LLM)
  - vs 单一检索 (仅BM25或仅向量)

统计检验:
  - McNemar检验 (F1提升显著性)
  - p < 0.05
```

### 模块B: 图学习
```yaml
必须达到:
  - 链路预测 AUC ≥ 0.80
  - 节点分类 Macro-F1 ≥ 0.75
  - 路径可解释性: ≥10个高权重路径回查成功

消融研究:
  - 去时序 (HGT only) → 性能下降
  - 去异质 (GAT/GCN) → 性能下降
  - 去RAG证据 (随机初始化) → 性能下降

时间切分验证:
  - Train<2020, Valid=2020, Test>2020
  - 无未来信息泄露
```

### 模块C: 因果推断
```yaml
必须达到:
  - 三估计器方向一致
  - 预趋势检验 p>0.05
  - 稳健性检验 ≥3项通过

对照实验:
  - vs TWFE (展示偏误)
  - vs 无控制变量
  - vs 删除先行试点

可视化:
  - 事件研究图 (95% CI)
  - CS-ATT热力图 (组-时点ATT)
  - 稳健性检验结果表
```

### 端到端: 校准与不确定性
```yaml
必须达到:
  - ECE ≤ 0.05 (温度缩放后)
  - 共形预测覆盖率 ≥ 90% (α=0.1)
  - 关键决策附不确定性说明

安全基线:
  - OWASP LLM Top 10全部遵守
  - 无Prompt Injection漏洞
  - 工具执行沙箱化
  - 审计日志完整
```

## 交付物清单(强制完成)

### 代码与文档
```yaml
必须交付:
  - 完整可运行的代码仓库
  - Makefile (所有目标可执行)
  - README.md (快速开始 + 依赖说明)
  - policy_schema.json (JSON Schema 2020-12)
  - 标注指南 (含示例与质量门槛)
  - requirements.txt (锁定版本)
  - Dockerfile / environment.yml
  - SHA256校验文件

禁止交付:
  - 不可运行的代码
  - 缺失依赖的脚本
  - 无文档的复杂配置
```

### 研究输出
```yaml
必须交付:
  - 分层评测结果表 (A/B/C模块)
  - 事件研究图 (CS-ATT/SA/BJS)
  - 图注意力热力图
  - RAG证据高亮示例
  - 校准可靠性图 (reliability diagram)
  - 消融研究对比表
  - 稳健性检验结果

禁止:
  - 单一估计器结果 (无验证)
  - 无预趋势图的因果结论
  - 未校准的模型输出
```

### 复现材料
```yaml
必须交付:
  - R sessionInfo() 输出
  - Python依赖版本列表
  - 随机种子设置说明
  - 数据SHA256校验和
  - 完整运行脚本
  - 预期运行时间估算

推荐交付:
  - Zenodo数据字典
  - arXiv预印本
  - 补充材料PDF
```

## 时间表与里程碑(6-8周)

```yaml
Week 1-2: 数据采集与标注
  里程碑:
    - 中央政策 2009-至今全量
    - 广东+2省示范政策
    - BM25+FAISS索引构建完成
    - 500-1000条金标标注完成
    - Cohen's κ ≥ 0.80

Week 3-4: 语义抽取与验证
  里程碑:
    - DAPT/TAPT微调完成
    - RAG管线部署
    - 模块A评测 F1≥0.85
    - ARES评测通过
    - 证据链可追溯

Week 5-6: 图学习与路径分析
  里程碑:
    - 异质图构建完成
    - HGT+TGAT训练完成
    - 模块B评测 AUC≥0.80
    - 消融研究完成
    - 10+路径回查验证

Week 7-8: 因果推断与复现
  里程碑:
    - 面板数据对齐 (3-5年)
    - CS-ATT/SA/BJS并行估计
    - 预趋势检验通过
    - 稳健性检验 ≥3项
    - 可视化图表完成
    - 复现包打包完成
    - 论文附录撰写完成
```

## 术语表与缩写

```yaml
中文术语:
  政策五元组: 目标、工具、对象、地域、时间
  强度分级: 0=背景, 1=倡议, 2=一般, 3=强约束
  域适配: DAPT (Domain-Adaptive Pre-Training)
  任务适配: TAPT (Task-Adaptive Pre-Training)
  检索增强: RAG (Retrieval-Augmented Generation)

英文缩写:
  CS-ATT: Callaway & Sant'Anna ATT
  SA: Sun & Abraham
  BJS: Borusyak-Jaravel-Spiess
  HGT: Heterogeneous Graph Transformer
  TGAT: Temporal Graph Attention Network
  TWFE: Two-Way Fixed Effects
  ECE: Expected Calibration Error
  NBS: National Bureau of Statistics
  CNIPA: China National Intellectual Property Administration

统计术语:
  g: 首次处理时点 (never=0)
  ATT: Average Treatment Effect on the Treated
  DID: Difference-in-Differences
  FE: Fixed Effects
  SE: Standard Errors
  CI: Confidence Interval
```

## 常见陷阱与强制规避

### 编码陷阱
```yaml
❌ 使用TWFE替代稳健DID → 必须用CS-ATT/SA/BJS
❌ 图模型使用全时间数据训练 → 严格时间切分
❌ 忽略evidence_spans → 强制可追溯
❌ 单一估计器报告因果结果 → 三方验证
❌ 未校准的模型直接使用 → ECE≤0.05
❌ 跳过预趋势检验 → 必须可视化并检验

✅ 正确做法:
  - CS-ATT + SA + BJS 并行
  - Train<t, Valid=t, Test>t
  - 所有抽取附证据
  - 事件研究图+预趋势检验
  - 温度缩放+共形预测
```

### 数据陷阱
```yaml
❌ 过度爬取政府网站 → QPS≤1.0 + 随机抖动
❌ 使用PSS批量爬取专利 → 仅用公开月报/年报
❌ 混淆统计口径 → 以NBS官方为准
❌ 行政区划码不一致 → 使用省级2位/6位标准码
❌ 政策落地时点不准 → 以正式文件effective_date为准

✅ 正确做法:
  - 遵守robots.txt + 节流
  - 仅用公开统计报告
  - 交叉验证统计指标
  - province_codes.csv统一映射
  - effective_date优先于pub_date
```

### 方法论陷阱
```yaml
❌ 声称"政策导致增长" → 应为"政策与增长正相关,在X假设下可能存在因果"
❌ 单一F1指标 → 必须报告P/R/F1 + Cohen's κ
❌ 黑盒图模型 → 必须提供路径可解释性
❌ 点估计无不确定性 → 必须附95% CI + 校准指标

✅ 正确做法:
  - 谨慎因果语言,列明假设
  - 多指标交叉验证
  - 高权重路径回查
  - 区间估计 + 不确定性量化
```

---

# 最终检查清单

在提交任何成果前,必须确认以下所有项目:

## 数据合规
- [ ] 所有数据来自公开政府网站
- [ ] robots.txt全部遵守
- [ ] QPS限制全部落实
- [ ] 无个人隐私数据
- [ ] 数据来源全部标注

## 代码质量
- [ ] 所有脚本可独立运行
- [ ] requirements.txt锁定版本
- [ ] 所有配置有默认值或示例
- [ ] 注释使用简体中文
- [ ] 无硬编码路径或密钥

## 方法论
- [ ] 三估计器 (CS-ATT/SA/BJS) 全部运行
- [ ] 预趋势检验通过 (p>0.05)
- [ ] 稳健性检验 ≥3项
- [ ] 时间切分无泄露
- [ ] 图模型 ≤3层

## 质量门槛
- [ ] F1 ≥ 0.85 或说明原因
- [ ] Cohen's κ ≥ 0.80 或仲裁
- [ ] ECE ≤ 0.05
- [ ] 所有抽取有evidence_spans
- [ ] 高风险分类有共形区间

## 复现性
- [ ] Makefile所有目标可执行
- [ ] Docker/Conda环境定义
- [ ] R sessionInfo() 记录
- [ ] SHA256校验文件
- [ ] 随机种子文档

## 文档完整性
- [ ] README.md快速开始
- [ ] policy_schema.json (JSON Schema 2020-12)
- [ ] 标注指南含质量门槛
- [ ] .claude/目录有三个md文件
- [ ] 所有来源有引用链接

---

**本准则的执行是强制性的,任何偏离必须在operations-log.md中记录并获得明确批准。**
